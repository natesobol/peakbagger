<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Profile Settings ‚Äì Peakbagger‚Äôs Journal</title>
<meta name="description" content="Manage your Peakbagger account, update preferences, and review hiking stats for the NH 48, 52 With a View and other peak lists." />
<meta name="keywords" content="Peakbagger profile, hiking account settings, NH 48 progress, peakbagging app, White Mountain hiking log" />
<link rel="canonical" href="https://nh48.app/pages/profile.html" />
<meta name="robots" content="index,follow,max-image-preview:large" />

<!-- Open Graph -->
<meta property="og:type" content="website" />
<meta property="og:url" content="https://nh48.app/pages/profile.html" />
<meta property="og:title" content="Profile Settings ‚Äì Peakbagger‚Äôs Journal" />
<meta property="og:description" content="Update your Peakbagger profile, sync settings, and track White Mountain peakbagging progress." />
<meta property="og:image" content="https://nh48pics.com/images/peakbagger-og.jpg" />
<meta property="og:image:alt" content="NH 4000 footers peaks overview with progress bar" />

<!-- Twitter -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Profile Settings ‚Äì Peakbagger‚Äôs Journal" />
<meta name="twitter:description" content="Update your Peakbagger profile, sync settings, and track White Mountain peakbagging progress." />
<meta name="twitter:image" content="https://nh48pics.com/images/peakbagger-og.jpg" />

<!-- JSON-LD: SoftwareApplication -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebApplication",
  "name": "Peakbagger‚Äôs Journal",
  "operatingSystem": "Web",
  "applicationCategory": "SportsApplication",
  "description": "Free hiking log for tracking New Hampshire‚Äôs 4000 footers, 52 With a View and other peak lists. Search, sort, filter and record your climbs and dates.",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "url": "https://nh48.app/pages/profile.html",
  "image": "https://nh48pics.com/images/peakbagger-og.jpg",
  "publisher": {
    "@type": "Person",
    "name": "Nathan Sobol",
    "url": "https://www.nh48pics.com/"
  }
}
</script>
<link rel="stylesheet" href="../css/styles.css">
<link rel="stylesheet" href="../css/profile.css">
<!-- URL Masking: hide /pages/ from URL bar -->
<script>
if (window.location.pathname.includes('/pages/')) {
  history.replaceState(null, '', '/profile');
}
</script>
</head>
<body>

<div class="profile-page">
  <div class="profile-header">
    <a href="peakbagger-clean.html" class="back-link">‚Üê Back to Peakbagger</a>
    <h1>Profile Settings</h1>
    <p class="subtitle">Manage your account information and security settings</p>
  </div>

  <!-- Dashboard Stats -->
  <div class="profile-card" id="dashboardStats" style="display:none">
    <div class="progress-header">
      <h2><span class="card-icon">üìä</span> Your Progress</h2>
      <div class="list-selector">
        <select id="progressListSelect" class="select">
          <option value="">Loading lists...</option>
        </select>
      </div>
    </div>
    
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-value accent" id="statTotalCompleted">0</div>
        <div class="stat-label">Peaks Completed</div>
      </div>
      <div class="stat-card">
        <div class="stat-value gold" id="statFavorites">0</div>
        <div class="stat-label">Favorites</div>
      </div>
      <div class="stat-card">
        <div class="stat-value red" id="statWishlist">0</div>
        <div class="stat-label">Wishlist</div>
      </div>
      <div class="stat-card">
        <div class="stat-value blue" id="statPercentComplete">0%</div>
        <div class="stat-label" id="statListName">Progress</div>
      </div>
    </div>

    <!-- GitHub-style Pulse Graph (104 weeks / 2 years) -->
    <div class="pulse-section">
      <div class="pulse-header">
        <h3 class="pulse-title">
          <span>üèîÔ∏è Hiking Activity</span>
          <span class="pulse-count" id="pulseHikeCount"></span>
        </h3>
      </div>
      <div class="pulse-subtitle">Peaks completed in the last 2 years</div>
      <div class="pulse-container" id="pulseGraph"></div>
      <div class="pulse-legend">
        <span>Less</span>
        <div class="pulse-legend-dots">
          <div class="pulse-legend-dot" style="background:rgba(34,197,94,0.1)"></div>
          <div class="pulse-legend-dot" style="background:rgba(34,197,94,0.3)"></div>
          <div class="pulse-legend-dot" style="background:rgba(34,197,94,0.6)"></div>
          <div class="pulse-legend-dot" style="background:#22c55e"></div>
        </div>
        <span>More</span>
      </div>
    </div>
  </div>

  <!-- User Information Card -->
  <div class="profile-card">
    <h2><span class="card-icon">üë§</span> User Information</h2>
    
    <div class="profile-avatar">
      <div class="profile-avatar-icon" id="profileAvatarIcon">
        <span id="profileInitials">U</span>
      </div>
      <div class="profile-avatar-info">
        <h3 id="profileName">Loading...</h3>
        <p id="profileEmail">Loading...</p>
        <span class="user-badge badge-member" id="memberBadge">üèîÔ∏è Member</span>
      </div>
    </div>

    <div class="info-grid">
      <div class="info-item">
        <label>Account Created</label>
        <span class="value" id="accountCreated">‚Äî</span>
      </div>
      <div class="info-item">
        <label>Last Sign In</label>
        <span class="value" id="lastSignIn">‚Äî</span>
      </div>
      <div class="info-item">
        <label>User ID</label>
        <span class="value subtle" id="userId">‚Äî</span>
      </div>
    </div>
  </div>

  <!-- Achievements Card -->
  <div class="profile-card">
    <h2><span class="card-icon">üèÜ</span> Achievements</h2>
    <div id="achievementsContainer">
      <div class="achievements-grid" id="achievementsGrid">
        <div class="no-logs-message">
          <div class="empty-icon">üéØ</div>
          <div>Loading achievements...</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Recent Hikes Card -->
  <div class="profile-card">
    <h2><span class="card-icon">ü•æ</span> Recent Hikes</h2>
    <div id="hikesContainer">
      <div class="no-logs-message">
        <div class="empty-icon">üèîÔ∏è</div>
        <div>Loading your hiking history...</div>
      </div>
    </div>
  </div>

  <!-- Social Features -->
  <div class="profile-card">
    <h2><span class="card-icon">ü§ù</span> Social</h2>
    
    <div class="social-container">
      <!-- User Search -->
      <div class="social-section">
        <h3>üîç Find Friends</h3>
        <div class="search-box">
          <input type="text" id="userSearchInput" placeholder="Search by name or email...">
          <button class="btn btn-primary btn-small" id="searchUsersBtn">Search</button>
        </div>
        <ul id="searchResults" class="user-list"></ul>
      </div>

      <!-- Friend Requests -->
      <div class="social-section">
        <h3>üì¨ Friend Requests</h3>
        <ul id="friendRequests" class="request-list">
          <li class="empty-state">No pending requests</li>
        </ul>
      </div>

      <!-- Friends List -->
      <div class="social-section full-width">
        <h3>üë• My Friends</h3>
        <ul id="friendsList" class="friend-list">
          <li class="empty-state">No friends yet. Search for hikers above to connect!</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Preferences Card -->
  <div class="profile-card">
    <h2><span class="card-icon">‚öôÔ∏è</span> Preferences</h2>
    
    <div class="preference-grid">
      <div class="toggle-row">
        <div class="toggle-info">
          <div class="toggle-label">Email Notifications</div>
          <div class="toggle-description">Receive weekly summaries and friend activity updates</div>
        </div>
        <label class="switch">
          <input type="checkbox" id="emailNotifications" checked>
          <span class="slider"></span>
        </label>
      </div>
      
      <div class="toggle-row">
        <div class="toggle-info">
          <div class="toggle-label">Public Profile</div>
          <div class="toggle-description">Allow other users to see your hiking progress</div>
        </div>
        <label class="switch">
          <input type="checkbox" id="publicProfile" checked>
          <span class="slider"></span>
        </label>
      </div>
      
      <div class="toggle-row">
        <div class="toggle-info">
          <div class="toggle-label">Sound Effects</div>
          <div class="toggle-description">Play sounds when completing peaks</div>
        </div>
        <label class="switch">
          <input type="checkbox" id="soundEffects" checked>
          <span class="slider"></span>
        </label>
      </div>
    </div>
  </div>

  <!-- Data Export Card -->
  <div class="profile-card">
    <h2><span class="card-icon">üíæ</span> Export Your Data</h2>
    <p style="color: var(--ink-weak); font-size: 14px; margin: 0 0 16px 0;">
      Download your hiking data for backup or to use in other applications.
    </p>
    
    <div class="export-section">
      <button class="export-btn" id="exportJsonBtn">
        <span class="icon">üìÑ</span>
        <span>Export as JSON</span>
      </button>
      <button class="export-btn" id="exportCsvBtn">
        <span class="icon">üìä</span>
        <span>Export as CSV</span>
      </button>
    </div>
  </div>

  <!-- Change Password Card -->
  <div class="profile-card">
    <h2><span class="card-icon">üîê</span> Change Password</h2>
    
    <div id="passwordMessage" class="message" style="display: none;"></div>

    <form id="changePasswordForm">
      <div class="form-group">
        <label for="currentPassword">Current Password *</label>
        <input type="password" id="currentPassword" autocomplete="current-password" required>
      </div>

      <div class="form-group">
        <label for="newPassword">New Password *</label>
        <input type="password" id="newPassword" autocomplete="new-password" required>
        <p class="hint">Must be at least 6 characters</p>
      </div>

      <div class="form-group">
        <label for="confirmPassword">Confirm New Password *</label>
        <input type="password" id="confirmPassword" autocomplete="new-password" required>
      </div>

      <div class="btn-group">
        <button type="submit" class="btn btn-primary">Update Password</button>
        <button type="reset" class="btn btn-ghost">Cancel</button>
      </div>
    </form>
  </div>

  <!-- Sign Out -->
  <div class="profile-card">
    <h2><span class="card-icon">üö™</span> Sign Out</h2>
    <p style="color:var(--ink-weak);font-size:14px;margin-bottom:16px">Sign out of your account on this device.</p>
    <button class="btn btn-secondary" id="signOutBtn">Sign Out</button>
  </div>

  <!-- Danger Zone -->
  <div class="profile-card">
    <div class="danger-zone">
      <h3>‚ö†Ô∏è Danger Zone</h3>
      <p>These actions are permanent and cannot be undone.</p>
      <div class="danger-actions">
        <button class="btn btn-danger" id="deleteAccountBtn" style="display:none">Delete Account</button>
      </div>
    </div>
  </div>
</div>

<!-- Confirmation Modal -->
<div class="modal-overlay" id="confirmModal">
  <div class="modal">
    <h3 id="modalTitle">Confirm Action</h3>
    <p id="modalMessage">Are you sure you want to proceed?</p>
    <div class="modal-actions">
      <button class="btn btn-ghost" id="modalCancel">Cancel</button>
      <button class="btn btn-danger" id="modalConfirm">Confirm</button>
    </div>
  </div>
</div>

<!-- Supabase client -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script type="module">
  // Initialize Supabase with persistent session
  const supabaseUrl = 'https://uobvavnsstrgyezcklib.supabase.co';
  const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVvYnZhdm5zc3RyZ3llemNrbGliIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU0ODEzNTksImV4cCI6MjA4MTA1NzM1OX0.KL32AFytJcOC5RPEPlWlCzBDiA8N_Su9qb0yXT2n2ZI';
  
  const supabase = window.supabase.createClient(supabaseUrl, supabaseAnonKey, {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: true,
      storage: window.localStorage
    }
  });

  let currentUser = null;
  let currentListId = null;

  // DOM elements
  const profileName = document.getElementById('profileName');
  const profileEmail = document.getElementById('profileEmail');
  const profileInitials = document.getElementById('profileInitials');
  const accountCreated = document.getElementById('accountCreated');
  const lastSignIn = document.getElementById('lastSignIn');
  const userId = document.getElementById('userId');
  const changePasswordForm = document.getElementById('changePasswordForm');
  const passwordMessage = document.getElementById('passwordMessage');
  const signOutBtn = document.getElementById('signOutBtn');
  const userSearchInput = document.getElementById('userSearchInput');
  const searchUsersBtn = document.getElementById('searchUsersBtn');
  const searchResults = document.getElementById('searchResults');
  const friendRequests = document.getElementById('friendRequests');
  const friendsList = document.getElementById('friendsList');

  // Load user data
  async function loadUserProfile() {
    const { data: { user }, error } = await supabase.auth.getUser();
    
    if (error || !user) {
      // Not logged in, redirect to main page
      window.location.href = 'peakbagger-clean.html';
      return;
    }

    currentUser = user;

    // Update UI with user data
    const firstName = user.user_metadata?.first_name || user.user_metadata?.name || 'User';
    const lastName = user.user_metadata?.last_name || '';
    const fullName = lastName ? `${firstName} ${lastName}` : firstName;

    profileName.textContent = fullName;
    profileEmail.textContent = user.email || '';
    userId.textContent = user.id;

    // Set initials
    const initials = firstName.charAt(0).toUpperCase() + (lastName ? lastName.charAt(0).toUpperCase() : '');
    profileInitials.textContent = initials || 'U';

    // Format dates
    if (user.created_at) {
      accountCreated.textContent = new Date(user.created_at).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
    }

    if (user.last_sign_in_at) {
      lastSignIn.textContent = new Date(user.last_sign_in_at).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }
  }

  // Show message
  function showMessage(text, isError = false) {
    passwordMessage.textContent = text;
    passwordMessage.className = 'message ' + (isError ? 'error' : 'success');
    passwordMessage.style.display = 'block';
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
      passwordMessage.style.display = 'none';
    }, 5000);
  }

  // Handle password change
  changePasswordForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const currentPassword = document.getElementById('currentPassword').value;
    const newPassword = document.getElementById('newPassword').value;
    const confirmPassword = document.getElementById('confirmPassword').value;

    // Validate passwords match
    if (newPassword !== confirmPassword) {
      showMessage('New passwords do not match', true);
      return;
    }

    // Validate password length
    if (newPassword.length < 6) {
      showMessage('Password must be at least 6 characters', true);
      return;
    }

    try {
      // First verify current password by trying to sign in
      const { error: signInError } = await supabase.auth.signInWithPassword({
        email: currentUser.email,
        password: currentPassword
      });

      if (signInError) {
        showMessage('Current password is incorrect', true);
        return;
      }

      // Update password
      const { error: updateError } = await supabase.auth.updateUser({
        password: newPassword
      });

      if (updateError) {
        showMessage(updateError.message, true);
        return;
      }

      // Success
      showMessage('Password updated successfully!');
      changePasswordForm.reset();
    } catch (err) {
      showMessage('An error occurred. Please try again.', true);
      console.error(err);
    }
  });

  // Handle sign out
  signOutBtn.addEventListener('click', async () => {
    if (!confirm('Are you sure you want to sign out?')) return;
    
    await supabase.auth.signOut();
    window.location.href = 'peakbagger-clean.html';
  });

  // Load profile on page load
  // Note: We call initializeProfile() instead of loadUserProfile() directly
  // to ensure social features are loaded after user data
  initializeProfile();
  
  // =====================================================
  // Hike Logs - Load from user_peak_progress (completed peaks)
  // DB Load: user_peak_progress, peaks, lists
  // =====================================================
  async function loadRecentHikes() {
    const hikesContainer = document.getElementById('hikesContainer');
    
    // Error handling: Check user authentication
    if (!currentUser) {
      console.log('loadRecentHikes: No currentUser yet, skipping');
      hikesContainer.innerHTML = `
        <div class="no-logs-message">
          <div class="empty-icon">üîí</div>
          <div>Please log in to view your hiking history</div>
        </div>
      `;
      return;
    }
    
    try {
      console.log('loadRecentHikes: Fetching completions for user:', currentUser.id);
      
      // DB Load: Get recent completions from user_peak_progress
      const { data: completions, error } = await supabase
        .from('user_peak_progress')
        .select('peak_id, list_id, completed, first_completed_at, last_completed_at')
        .eq('user_id', currentUser.id)
        .eq('completed', true)
        .order('first_completed_at', { ascending: false })
        .limit(10);
      
      if (error) {
        console.error('loadRecentHikes: DB Load Error:', error);
        throw error;
      }
      
      console.log('loadRecentHikes: Found completions:', completions?.length || 0);
      
      // Handle no data case
      if (!completions || completions.length === 0) {
        hikesContainer.innerHTML = `
          <div class="no-logs-message">
            <div class="empty-icon">ü•æ</div>
            <div>No peaks completed yet</div>
            <p style="margin-top:8px;font-size:13px">Start tracking your hikes to see them here!</p>
            <a href="peakbagger-clean.html" class="btn btn-primary btn-small" style="margin-top:16px">Browse Peaks</a>
          </div>
        `;
        return;
      }
      
      // DB Load: Fetch peak and list names separately for each completion
      const enrichedCompletions = await Promise.all(completions.map(async (item) => {
        let peakName = '‚Äî';
        let peakSlug = '';
        let listName = '‚Äî';
        
        // DB Load: Get peak info from peaks table
        if (item.peak_id) {
          const { data: peak, error: peakError } = await supabase
            .from('peaks')
            .select('name, slug')
            .eq('id', item.peak_id)
            .single();
          if (peakError) {
            console.warn('loadRecentHikes: DB Load peak error:', peakError);
          }
          if (peak) {
            peakName = peak.name;
            peakSlug = peak.slug || '';
          }
        }
        
        // DB Load: Get list info from lists table
        if (item.list_id) {
          const { data: list, error: listError } = await supabase
            .from('lists')
            .select('name')
            .eq('id', item.list_id)
            .single();
          if (listError) {
            console.warn('loadRecentHikes: DB Load list error:', listError);
          }
          if (list) {
            listName = list.name;
          }
        }
        
        return {
          ...item,
          peakName,
          peakSlug,
          listName
        };
      }));
      
      const tableHtml = `
        <table class="hike-logs-table">
          <thead>
            <tr>
              <th>Date</th>
              <th>Peak</th>
              <th>List</th>
              <th style="width:50px;text-align:center;">Share</th>
            </tr>
          </thead>
          <tbody>
            ${enrichedCompletions.map(item => {
              const date = item.first_completed_at || item.last_completed_at;
              const formattedDate = date ? new Date(date).toLocaleDateString('en-US', { 
                month: 'short', day: 'numeric', year: 'numeric' 
              }) : '‚Äî';
              return `
                <tr>
                  <td style="cursor:pointer" onclick="window.location.href='peak-detail.html?slug=${item.peakSlug}'">${formattedDate}</td>
                  <td style="cursor:pointer" onclick="window.location.href='peak-detail.html?slug=${item.peakSlug}'">${item.peakName}</td>
                  <td style="cursor:pointer" onclick="window.location.href='peak-detail.html?slug=${item.peakSlug}'">${item.listName}</td>
                  <td style="text-align:center">
                    <button class="social-card-btn" onclick="event.stopPropagation(); window.location.href='social-card.html?peak=${item.peakSlug}&progress=${item.id}'" title="Generate Social Card">
                      üì∏
                    </button>
                  </td>
                </tr>
              `;
            }).join('')}
          </tbody>
        </table>
      `;
      
      hikesContainer.innerHTML = tableHtml;
      console.log('loadRecentHikes: Successfully rendered', enrichedCompletions.length, 'hikes');
      
    } catch (e) {
      console.error('Error loading hikes:', e);
      hikesContainer.innerHTML = `
        <div class="no-logs-message">
          <div class="empty-icon">‚ö†Ô∏è</div>
          <div>Error loading hikes</div>
          <p style="margin-top:8px;font-size:12px;color:var(--ink-weak)">${e.message || 'Unknown error'}</p>
          <button onclick="loadRecentHikes()" class="btn btn-ghost btn-small" style="margin-top:12px">Try Again</button>
        </div>
      `;
    }
  }
  
  // =====================================================
  // Social Features - User Search
  // DB Load: profiles, friendships, friend_requests
  // =====================================================
  async function searchUsers() {
    const query = userSearchInput.value.trim().toLowerCase();
    if (!query || query.length < 2) {
      searchResults.innerHTML = '<li class="empty-state">Enter at least 2 characters</li>';
      return;
    }
    
    // Error handling: Check user authentication
    if (!currentUser) {
      searchResults.innerHTML = '<li class="empty-state">Please log in to search users</li>';
      return;
    }
    
    try {
      // DB Load: Search profiles table
      const { data: users, error } = await supabase
        .from('profiles')
        .select('id, email, display_name')
        .or(`display_name.ilike.%${query}%,email.ilike.%${query}%`)
        .neq('id', currentUser.id)
        .limit(10);
      
      if (error) {
        console.error('searchUsers: DB Load Error:', error);
        throw error;
      }
      
      // Handle no results
      if (!users || users.length === 0) {
        searchResults.innerHTML = '<li class="empty-state">No users found</li>';
        return;
      }
      
      // DB Load: Check existing friendships
      const { data: existingFriendships, error: friendError } = await supabase
        .from('friendships')
        .select('friend_user_id')
        .eq('user_id', currentUser.id);
      
      if (friendError) {
        console.warn('searchUsers: DB Load friendships warning:', friendError);
      }
      
      // DB Load: Check sent friend requests
      const { data: sentRequests, error: reqError } = await supabase
        .from('friend_requests')
        .select('to_user_id')
        .eq('from_user_id', currentUser.id)
        .eq('status', 'pending');
      
      if (reqError) {
        console.warn('searchUsers: DB Load friend_requests warning:', reqError);
      }
      
      const friendIds = new Set(existingFriendships?.map(f => f.friend_user_id) || []);
      const requestIds = new Set(sentRequests?.map(r => r.to_user_id) || []);
      
      searchResults.innerHTML = users.map(user => {
        const initials = getInitials(user.display_name || user.email);
        const isFriend = friendIds.has(user.id);
        const hasPendingRequest = requestIds.has(user.id);
        
        let actionButton = '';
        if (isFriend) {
          actionButton = '<span class="badge badge-accepted">Friends</span>';
        } else if (hasPendingRequest) {
          actionButton = '<span class="badge badge-pending">Pending</span>';
        } else {
          actionButton = `<button class="btn btn-primary btn-icon" onclick="sendFriendRequest('${user.id}')">Add Friend</button>`;
        }
        
        return `
          <li class="user-item">
            <div class="user-info">
              <div class="user-avatar-small">${initials}</div>
              <div class="user-details">
                <div class="name">${user.display_name || 'User'}</div>
                <div class="email">${user.email}</div>
              </div>
            </div>
            <div class="action-buttons">
              ${actionButton}
            </div>
          </li>
        `;
      }).join('');
    } catch (e) {
      console.error('Error searching users:', e);
      searchResults.innerHTML = '<li class="empty-state">Error searching users</li>';
    }
  }
  
  function getInitials(name) {
    if (!name) return 'U';
    const parts = name.split(' ');
    if (parts.length >= 2) {
      return parts[0][0].toUpperCase() + parts[1][0].toUpperCase();
    }
    return name.substring(0, 2).toUpperCase();
  }
  
  // Make sendFriendRequest globally accessible
  window.sendFriendRequest = async function(toUserId) {
    try {
      const { error } = await supabase
        .from('friend_requests')
        .insert({
          from_user_id: currentUser.id,
          to_user_id: toUserId,
          status: 'pending'
        });
      
      if (error) throw error;
      
      // Refresh search results
      await searchUsers();
      showMessage('Friend request sent!');
    } catch (e) {
      console.error('Error sending friend request:', e);
      showMessage('Error sending friend request', true);
    }
  };
  
  // =====================================================
  // Social Features - Friend Requests
  // DB Load: friend_requests, profiles
  // DB Save: friend_requests (update status), friendships (create)
  // =====================================================
  async function loadFriendRequests() {
    // Error handling: Check user authentication
    if (!currentUser) {
      console.log('loadFriendRequests: No user, skipping');
      friendRequests.innerHTML = '<li class="empty-state">Please log in</li>';
      return;
    }
    
    try {
      // DB Load: Get pending friend requests from friend_requests table
      const { data: requests, error } = await supabase
        .from('friend_requests')
        .select('id, from_user_id, to_user_id, status, created_at')
        .eq('to_user_id', currentUser.id)
        .eq('status', 'pending')
        .order('created_at', { ascending: false });
      
      if (error) {
        console.warn('loadFriendRequests: DB Load Error (table may not exist):', error.message);
        friendRequests.innerHTML = '<li class="empty-state">No pending requests</li>';
        return;
      }
      
      // Handle no data case
      if (!requests || requests.length === 0) {
        friendRequests.innerHTML = '<li class="empty-state">No pending requests</li>';
        return;
      }
      
      console.log('loadFriendRequests: DB Load successful, found', requests.length, 'requests');
      
      // DB Load: Fetch user profiles from profiles table
      const enrichedRequests = await Promise.all(requests.map(async (req) => {
        const { data: profile, error: profileError } = await supabase
          .from('profiles')
          .select('id, email, display_name')
          .eq('id', req.from_user_id)
          .single();
        
        if (profileError) {
          console.warn('loadFriendRequests: DB Load profile error:', profileError);
        }
        
        return {
          ...req,
          from_user: profile || { id: req.from_user_id, email: 'Unknown', display_name: null }
        };
      }));
      
      friendRequests.innerHTML = enrichedRequests.map(req => {
        const user = req.from_user;
        const initials = getInitials(user.display_name || user.email);
        
        return `
          <li class="request-item">
            <div class="user-info">
              <div class="user-avatar-small">${initials}</div>
              <div class="user-details">
                <div class="name">${user.display_name || 'User'}</div>
                <div class="email">${user.email}</div>
              </div>
            </div>
            <div class="action-buttons">
              <button class="btn btn-primary btn-icon" onclick="acceptFriendRequest('${req.id}', '${req.from_user_id}')">Accept</button>
              <button class="btn btn-ghost btn-icon" onclick="rejectFriendRequest('${req.id}')">Decline</button>
            </div>
          </li>
        `;
      }).join('');
    } catch (e) {
      console.error('loadFriendRequests: Error:', e);
      friendRequests.innerHTML = '<li class="empty-state">No pending requests</li>';
    }
  }
  
  // DB Save: Accept friend request - updates friend_requests and creates friendships
  window.acceptFriendRequest = async function(requestId, friendUserId) {
    try {
      // DB Save: Update request status in friend_requests
      const { error: updateError } = await supabase
        .from('friend_requests')
        .update({ status: 'accepted', updated_at: new Date().toISOString() })
        .eq('id', requestId);
      
      if (updateError) {
        console.error('acceptFriendRequest: DB Save Error:', updateError);
        throw updateError;
      }
      
      // DB Save: Create bidirectional friendships in friendships table
      const { error: friendship1Error } = await supabase
        .from('friendships')
        .insert({
          user_id: currentUser.id,
          friend_user_id: friendUserId
        });
      
      const { error: friendship2Error } = await supabase
        .from('friendships')
        .insert({
          user_id: friendUserId,
          friend_user_id: currentUser.id
        });
      
      if (friendship1Error || friendship2Error) throw friendship1Error || friendship2Error;
      
      // Refresh lists
      await loadFriendRequests();
      await loadFriends();
      showMessage('Friend request accepted!');
    } catch (e) {
      console.error('Error accepting friend request:', e);
      showMessage('Error accepting request', true);
    }
  };
  
  // DB Save: Reject friend request - updates friend_requests status
  window.rejectFriendRequest = async function(requestId) {
    try {
      // DB Save: Update request status to rejected
      const { error } = await supabase
        .from('friend_requests')
        .update({ status: 'rejected', updated_at: new Date().toISOString() })
        .eq('id', requestId);
      
      if (error) {
        console.error('rejectFriendRequest: DB Save Error:', error);
        throw error;
      }
      
      console.log('rejectFriendRequest: DB Save successful');
      await loadFriendRequests(); // DB Load: Refresh list
      showMessage('Friend request declined');
    } catch (e) {
      console.error('rejectFriendRequest: Error:', e);
      showMessage('Error declining request', true);
    }
  };
  
  // =====================================================
  // Social Features - Friends List
  // DB Load: friendships, profiles
  // DB Save: friendships (delete on remove)
  // =====================================================
  async function loadFriends() {
    // Error handling: Check user authentication
    if (!currentUser) {
      console.log('loadFriends: No user, skipping');
      friendsList.innerHTML = '<li class="empty-state">Please log in</li>';
      return;
    }
    
    try {
      // DB Load: Get friendships from friendships table
      const { data: friendships, error } = await supabase
        .from('friendships')
        .select('id, user_id, friend_user_id, created_at')
        .eq('user_id', currentUser.id)
        .order('created_at', { ascending: false });
      
      if (error) {
        console.warn('loadFriends: DB Load Error (table may not exist):', error.message);
        friendsList.innerHTML = '<li class="empty-state">No friends yet</li>';
        return;
      }
      
      // Handle no data case
      if (!friendships || friendships.length === 0) {
        friendsList.innerHTML = '<li class="empty-state">No friends yet</li>';
        return;
      }
      
      console.log('loadFriends: DB Load successful, found', friendships.length, 'friends');
      
      // DB Load: Fetch friend profiles from profiles table
      const enrichedFriendships = await Promise.all(friendships.map(async (friendship) => {
        const { data: profile, error: profileError } = await supabase
          .from('profiles')
          .select('id, email, display_name')
          .eq('id', friendship.friend_user_id)
          .single();
        
        if (profileError) {
          console.warn('loadFriends: DB Load profile error:', profileError);
        }
        
        return {
          ...friendship,
          friend: profile || { id: friendship.friend_user_id, email: 'Unknown', display_name: null }
        };
      }));
      
      friendsList.innerHTML = enrichedFriendships.map(friendship => {
        const friend = friendship.friend;
        const initials = getInitials(friend.display_name || friend.email);
        
        return `
          <li class="friend-item">
            <div class="user-info">
              <div class="user-avatar-small">${initials}</div>
              <div class="user-details">
                <div class="name">${friend.display_name || 'User'}</div>
                <div class="email">${friend.email}</div>
              </div>
            </div>
            <div class="action-buttons">
              <button class="btn btn-ghost btn-icon" onclick="removeFriend('${friendship.id}', '${friend.id}')">Remove</button>
            </div>
          </li>
        `;
      }).join('');
    } catch (e) {
      console.error('Error loading friends:', e);
      friendsList.innerHTML = '<li class="empty-state">No friends yet</li>';
    }
  }
  
  window.removeFriend = async function(friendshipId, friendUserId) {
    if (!confirm('Are you sure you want to remove this friend?')) return;
    
    try {
      // Remove both directions of friendship
      await supabase
        .from('friendships')
        .delete()
        .eq('id', friendshipId);
      
      await supabase
        .from('friendships')
        .delete()
        .eq('user_id', friendUserId)
        .eq('friend_user_id', currentUser.id);
      
      await loadFriends();
      showMessage('Friend removed');
    } catch (e) {
      console.error('Error removing friend:', e);
      showMessage('Error removing friend', true);
    }
  };
  
  // Event listeners
  searchUsersBtn.addEventListener('click', searchUsers);
  userSearchInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') searchUsers();
  });
  
  // All available lists
  let allLists = [];
  
  // =====================================================
  // Load all lists and populate the dropdown
  // DB Load: lists
  // =====================================================
  async function loadAllLists() {
    try {
      // DB Load: Get all lists from lists table
      const { data: lists, error } = await supabase
        .from('lists')
        .select('id, name, slug')
        .order('name', { ascending: true });
      
      if (error) {
        console.error('loadAllLists: DB Load Error:', error);
        return [];
      }
      
      allLists = lists || [];
      console.log('loadAllLists: DB Load successful, found', allLists.length, 'lists');
      
      // Populate dropdown with error handling
      const select = document.getElementById('progressListSelect');
      if (select) {
        if (allLists.length > 0) {
          select.innerHTML = allLists.map(list => 
            `<option value="${list.id}">${list.name}</option>`
          ).join('');
          
          // Add change event listener for DB Load on list change
          select.addEventListener('change', async (e) => {
            currentListId = e.target.value;
            await loadDashboardStats(); // DB Load triggered
          });
        } else {
          select.innerHTML = '<option value="">No lists available</option>';
        }
      }
      
      return allLists;
    } catch (e) {
      console.error('loadAllLists: Error:', e);
      return [];
    }
  }
  
  // =====================================================
  // Load default list ID - find most recent logged list or default to NH48
  // DB Load: user_peak_progress
  // =====================================================
  async function loadDefaultList() {
    try {
      // First load all lists
      await loadAllLists();
      
      // Error handling: Check user authentication
      if (!currentUser) {
        console.log('loadDefaultList: No user, using first list');
        if (allLists.length > 0) {
          currentListId = allLists[0].id;
        }
        return;
      }
      
      // DB Load: Try to find the most recent list the user has logged to
      const { data: recentLog, error: recentError } = await supabase
        .from('user_peak_progress')
        .select('list_id')
        .eq('user_id', currentUser.id)
        .eq('completed', true)
        .order('first_completed_at', { ascending: false })
        .limit(1)
        .single();
      
      if (!recentError && recentLog?.list_id) {
        currentListId = recentLog.list_id;
        console.log('loadDefaultList: DB Load successful, using most recent list:', currentListId);
        
        // Update dropdown to match
        const select = document.getElementById('progressListSelect');
        if (select) select.value = currentListId;
        return;
      }
      
      // Fallback to NH48
      const nh48 = allLists.find(l => l.slug === 'nh48');
      if (nh48) {
        currentListId = nh48.id;
        console.log('loadDefaultList: Defaulting to NH48:', currentListId);
        
        // Update dropdown to match
        const select = document.getElementById('progressListSelect');
        if (select) select.value = currentListId;
        return;
      }
      
      // Last resort - use first available list
      if (allLists.length > 0) {
        currentListId = allLists[0].id;
        console.log('loadDefaultList: Using first available list:', currentListId);
        
        const select = document.getElementById('progressListSelect');
        if (select) select.value = currentListId;
      }
    } catch (e) {
      console.error('loadDefaultList: Error:', e);
    }
  }
  
  // Initialize social features after user loads
  async function initializeSocialFeatures() {
    console.log('initializeSocialFeatures: Starting initialization');
    
    try {
      // Load default list first - needed for dashboard stats
      await loadDefaultList();
      console.log('initializeSocialFeatures: Default list loaded, currentListId:', currentListId);
    } catch (e) {
      console.error('initializeSocialFeatures: Error loading default list:', e);
    }
    
    // Load features in parallel where possible, but catch individual errors
    const loadPromises = [
      loadRecentHikes().catch(e => console.error('Failed to load recent hikes:', e)),
      loadAchievements().catch(e => console.error('Failed to load achievements:', e)),
      loadFriendRequests().catch(e => console.error('Failed to load friend requests:', e)),
      loadFriends().catch(e => console.error('Failed to load friends:', e)),
    ];
    
    await Promise.all(loadPromises);
    
    // Load dashboard stats last (depends on list being loaded)
    try {
      await loadDashboardStats();
      console.log('initializeSocialFeatures: Dashboard stats loaded');
    } catch (e) {
      console.error('initializeSocialFeatures: Error loading dashboard stats:', e);
    }
    
    console.log('initializeSocialFeatures: All features initialized');
  }
  
  // =====================================================
  // Achievement Progress Calculator
  // Returns { current, target, percent } for ascent-based achievements
  // =====================================================
  function getAchievementProgress(type, ascentsCount) {
    const thresholds = {
      'first_ascent': 1,
      'rookie_hiker': 5,
      'mountaineer': 25,
      'peakbagger_club': 100,
      'century_unique': 100,
      'year_marathon': 50,
      'fourteeners': 14,
      'trip_reporter': 10,
      'photographer': 20
    };
    
    const target = thresholds[type];
    if (!target) return null; // Non-ascent based achievement
    
    const current = Math.min(ascentsCount, target);
    const percent = Math.round((current / target) * 100);
    
    return { current, target, percent };
  }
  
  // =====================================================
  // Achievements (25 total)
  // =====================================================
  // Icon files go in /ico folder as 512x512 PNG
  // Named: {achievement_type}.png (e.g., first_ascent.png)
  // =====================================================
  const ALL_ACHIEVEMENTS = [
    // Milestones (1-5)
    { type: 'first_ascent', name: 'First Summit', desc: 'Log your first ascent', icon: 'üèîÔ∏è', category: 'milestones' },
    { type: 'rookie_hiker', name: 'Rookie Hiker', desc: 'Log 5 ascents', icon: 'ü•æ', category: 'milestones' },
    { type: 'mountaineer', name: 'Mountaineer', desc: 'Log 25 ascents', icon: '‚õ∞Ô∏è', category: 'milestones' },
    { type: 'peakbagger_club', name: 'Peakbagger Club', desc: 'Log 100 ascents', icon: 'üèÜ', category: 'milestones' },
    { type: 'century_unique', name: 'Century of Peaks', desc: 'Visit 100 unique summits', icon: 'üíØ', category: 'milestones' },
    // Exploration (6-7)
    { type: 'world_explorer', name: 'World Explorer', desc: 'Ascents in 5 countries', icon: 'üåç', category: 'exploration' },
    { type: 'state_high_points', name: 'State High Points', desc: 'High-point 5 U.S. states', icon: 'üó∫Ô∏è', category: 'exploration' },
    // Lists (8-9, 15)
    { type: 'range_completer', name: 'Range Completer', desc: 'Finish a peak range', icon: 'üèîÔ∏è', category: 'lists' },
    { type: 'list_master', name: 'List Master', desc: 'Complete 3 peak lists', icon: 'üìã', category: 'lists' },
    // Altitude (10-11, 19, 25)
    { type: 'altitude_seeker', name: 'Altitude Seeker', desc: 'Summit above 4,000m (13,123 ft)', icon: 'üéØ', category: 'altitude' },
    { type: 'fourteeners', name: 'Fourteen Fourteeners', desc: 'Summit 14 peaks above 14,000 ft', icon: 'üîù', category: 'altitude' },
    // Community (12-14)
    { type: 'trip_reporter', name: 'Trip Reporter', desc: 'Publish 10 trip reports', icon: 'üìù', category: 'community' },
    { type: 'photographer', name: 'Trail Photographer', desc: 'Upload 20 photos', icon: 'üì∑', category: 'community' },
    { type: 'trailblazer', name: 'Trailblazer', desc: 'First to log a new peak', icon: 'üî•', category: 'community' },
    // Lists continued
    { type: 'custom_completist', name: 'Custom Completist', desc: 'Finish a custom list', icon: '‚ú®', category: 'lists' },
    // Seasons (16, 23)
    { type: 'seasonal_hiker', name: 'Seasonal Hiker', desc: 'Ascents in all 4 seasons', icon: 'üçÇ', category: 'seasons' },
    // Streaks (17, 20)
    { type: 'week_streak', name: 'Week-long Streak', desc: 'Ascents on 7 consecutive days', icon: 'üî•', category: 'streaks' },
    // Social (18)
    { type: 'partner_climber', name: 'Partner Climber', desc: 'Tag 10 companions', icon: 'üë•', category: 'social' },
    // Altitude continued
    { type: 'elevation_gain', name: 'Elevation Gain', desc: 'One ascent with >1,000m elevation gain', icon: 'üìà', category: 'altitude' },
    // Streaks continued
    { type: 'year_marathon', name: 'Yearly Marathon', desc: '50 ascents in one year', icon: 'üóìÔ∏è', category: 'streaks' },
    // Exploration continued
    { type: 'globetrotter', name: 'Globetrotter', desc: 'Ascents on 3 continents', icon: '‚úàÔ∏è', category: 'exploration' },
    // Special (22, 24)
    { type: 'night_hiker', name: 'Night Hiker', desc: 'Ascent starting after 6pm or finishing after midnight', icon: 'üåô', category: 'special' },
    // Seasons continued
    { type: 'winter_warrior', name: 'Winter Warrior', desc: 'Winter summit (December-February)', icon: '‚ùÑÔ∏è', category: 'seasons' },
    // Special continued
    { type: 'repeat_offender', name: 'Repeat Offender', desc: 'Same summit on 10 occasions', icon: 'üîÑ', category: 'special' },
    // Altitude continued
    { type: 'personal_best', name: 'Personal Best', desc: 'Highest elevation record above 5,000m', icon: 'üëë', category: 'altitude' },
  ];
  
  // Get icon URL for achievement (PNG from /ico folder, fallback to emoji)
  function getAchievementIcon(type, fallbackEmoji) {
    return `<img src="/ico/${type}.png" alt="" class="achievement-icon-img" onerror="this.style.display='none';this.nextElementSibling.style.display='inline'"><span class="achievement-icon-emoji" style="display:none">${fallbackEmoji}</span>`;
  }
  
  // =====================================================
  // Load Achievements
  // DB Load: user_achievements, user_peak_progress (fallback)
  // =====================================================
  async function loadAchievements() {
    const container = document.getElementById('achievementsGrid');
    
    // Error handling: Check user authentication
    if (!currentUser) {
      console.log('loadAchievements: No currentUser yet, skipping');
      container.innerHTML = '<div class="empty-state">Please log in to view achievements</div>';
      return;
    }
    
    console.log('loadAchievements: Loading for user:', currentUser.id);
    
    try {
      // DB Load: Get user progress count first
      let userProgressCount = 0;
      let progressData = [];
      try {
        const { data: progress, count } = await supabase
          .from('user_peak_progress')
          .select('peak_id, first_completed_at', { count: 'exact' })
          .eq('user_id', currentUser.id)
          .eq('completed', true)
          .order('first_completed_at', { ascending: true });
        userProgressCount = count || 0;
        progressData = progress || [];
      } catch (e) {
        console.log('Could not get progress count for achievements');
      }
      
      // DB Load: Try to load earned achievements from user_achievements table
      const { data: earned, error } = await supabase
        .from('user_achievements')
        .select('*')
        .eq('user_id', currentUser.id)
        .order('earned_at', { ascending: false });
      
      if (error) {
        // Table might not exist yet - fall back to calculated achievements
        console.log('loadAchievements: DB Load Error (table may not exist):', error.message);
        console.log('loadAchievements: Falling back to calculated achievements');
        await loadCalculatedAchievements(container);
        return;
      }
      
      console.log('loadAchievements: DB Load successful, found', earned?.length || 0, 'earned achievements');
      
      // Build earned map from DB
      const earnedMap = new Map(earned?.map(a => [a.achievement_type, a]) || []);
      
      // Calculate achievements that SHOULD be earned based on progress
      // This fills in any gaps where the DB wasn't updated
      const calculatedEarned = calculateEarnedAchievements(progressData, userProgressCount);
      calculatedEarned.forEach(calc => {
        if (!earnedMap.has(calc.type)) {
          earnedMap.set(calc.type, {
            achievement_type: calc.type,
            achievement_name: calc.name,
            earned_at: calc.date
          });
        }
      });
      
      // Render all achievements (earned + locked with progress bars)
      let html = '';
      
      ALL_ACHIEVEMENTS.forEach(ach => {
        const earnedAch = earnedMap.get(ach.type);
        const isEarned = !!earnedAch;
        const earnedDate = earnedAch?.earned_at ? new Date(earnedAch.earned_at).toLocaleDateString('en-US', {
          month: 'short', day: 'numeric', year: 'numeric'
        }) : null;
        
        // Calculate progress for ascent-based achievements
        const progressInfo = getAchievementProgress(ach.type, userProgressCount);
        
        html += `
          <div class="achievement-card ${isEarned ? '' : 'locked'}" title="${ach.desc}" data-category="${ach.category}">
            <div class="achievement-icon">
              <img src="/ico/${ach.type}.png" alt="${ach.name}" class="achievement-icon-img" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'">
              <span class="achievement-icon-emoji" style="display:none">${ach.icon}</span>
            </div>
            <div class="achievement-name">${earnedAch?.achievement_name || ach.name}</div>
            <div class="achievement-desc">${ach.desc}</div>
            <span class="achievement-date">${isEarned ? (earnedDate || 'Earned') : 'Not earned'}</span>
            ${!isEarned && progressInfo ? `
              <div class="achievement-progress">
                <div class="achievement-progress-bar">
                  <div class="achievement-progress-fill" style="width: ${progressInfo.percent}%"></div>
                </div>
                <div class="achievement-progress-text">${progressInfo.current}/${progressInfo.target}</div>
              </div>
            ` : ''}
          </div>
        `;
      });
      
      // Handle no achievements earned case
      container.innerHTML = html || '<div class="empty-state">Start hiking to earn achievements!</div>';
      console.log('loadAchievements: Rendered', ALL_ACHIEVEMENTS.length, 'achievement cards');
      
    } catch (e) {
      console.error('loadAchievements: Error:', e);
      // Try fallback to calculated achievements
      try {
        await loadCalculatedAchievements(container);
      } catch (fallbackError) {
        console.error('Fallback also failed:', fallbackError);
        container.innerHTML = '<div class="empty-state">Could not load achievements</div>';
      }
    }
  }
  
  // Calculate which achievements should be earned based on progress data
  function calculateEarnedAchievements(progress, count) {
    const earned = [];
    
    // Milestone achievements
    if (count >= 1 && progress[0]) {
      earned.push({ type: 'first_ascent', name: 'First Summit', date: progress[0].first_completed_at });
    }
    if (count >= 5 && progress[4]) {
      earned.push({ type: 'rookie_hiker', name: 'Rookie Hiker', date: progress[4].first_completed_at });
    }
    if (count >= 25 && progress[24]) {
      earned.push({ type: 'mountaineer', name: 'Mountaineer', date: progress[24].first_completed_at });
    }
    if (count >= 100 && progress[99]) {
      earned.push({ type: 'peakbagger_club', name: 'Peakbagger Club', date: progress[99].first_completed_at });
    }
    
    // Unique peaks
    const uniquePeaks = new Set(progress.map(p => p.peak_id));
    if (uniquePeaks.size >= 100) {
      earned.push({ type: 'century_unique', name: 'Century of Peaks', date: progress[progress.length - 1]?.first_completed_at });
    }
    
    // Winter Warrior
    const winterPeaks = progress.filter(p => {
      if (!p.first_completed_at) return false;
      const month = new Date(p.first_completed_at).getMonth() + 1;
      return month === 12 || month === 1 || month === 2;
    });
    if (winterPeaks.length > 0) {
      earned.push({ type: 'winter_warrior', name: 'Winter Warrior', date: winterPeaks[0].first_completed_at });
    }
    
    // Seasonal Hiker
    const seasons = new Set();
    progress.forEach(p => {
      if (!p.first_completed_at) return;
      const month = new Date(p.first_completed_at).getMonth() + 1;
      if (month === 12 || month === 1 || month === 2) seasons.add('winter');
      else if (month >= 3 && month <= 5) seasons.add('spring');
      else if (month >= 6 && month <= 8) seasons.add('summer');
      else seasons.add('fall');
    });
    if (seasons.size === 4) {
      earned.push({ type: 'seasonal_hiker', name: 'Seasonal Hiker', date: progress[progress.length - 1]?.first_completed_at });
    }
    
    return earned;
  }
  
  // Fallback: Calculate achievements from progress data if table doesn't exist
  async function loadCalculatedAchievements(container) {
    console.log('loadCalculatedAchievements: Starting fallback calculation');
    
    try {
      const { data: progress, error } = await supabase
        .from('user_peak_progress')
        .select('peak_id, first_completed_at')
        .eq('user_id', currentUser.id)
        .eq('completed', true)
        .order('first_completed_at', { ascending: true });
      
      if (error) {
        console.error('loadCalculatedAchievements: Query error:', error);
        throw error;
      }
      
      console.log('loadCalculatedAchievements: Found progress records:', progress?.length || 0);
      
      const count = progress?.length || 0;
      const uniquePeaks = new Set(progress?.map(p => p.peak_id) || []);
      const uniqueCount = uniquePeaks.size;
      const earnedAchievements = [];
      
      // 1. first_ascent - First Summit (1 ascent)
      if (count >= 1) {
        earnedAchievements.push({
          type: 'first_ascent',
          name: 'First Summit',
          icon: 'üèîÔ∏è',
          desc: 'Log your first ascent',
          date: progress[0]?.first_completed_at,
          category: 'milestones'
        });
      }
      
      // 2. rookie_hiker - Rookie Hiker (5 ascents)
      if (count >= 5) {
        earnedAchievements.push({
          type: 'rookie_hiker',
          name: 'Rookie Hiker',
          icon: 'ü•æ',
          desc: 'Log 5 ascents',
          date: progress[4]?.first_completed_at,
          category: 'milestones'
        });
      }
      
      // 3. mountaineer - Mountaineer (25 ascents)
      if (count >= 25) {
        earnedAchievements.push({
          type: 'mountaineer',
          name: 'Mountaineer',
          icon: '‚õ∞Ô∏è',
          desc: 'Log 25 ascents',
          date: progress[24]?.first_completed_at,
          category: 'milestones'
        });
      }
      
      // 4. peakbagger_club - Peakbagger Club (100 ascents)
      if (count >= 100) {
        earnedAchievements.push({
          type: 'peakbagger_club',
          name: 'Peakbagger Club',
          icon: 'üèÜ',
          desc: 'Log 100 ascents',
          date: progress[99]?.first_completed_at,
          category: 'milestones'
        });
      }
      
      // 5. century_unique - Century of Peaks (100 unique summits)
      if (uniqueCount >= 100) {
        earnedAchievements.push({
          type: 'century_unique',
          name: 'Century of Peaks',
          icon: 'üíØ',
          desc: 'Visit 100 unique summits',
          date: progress[99]?.first_completed_at,
          category: 'milestones'
        });
      }
      
      // 23. winter_warrior - Winter Warrior (Dec, Jan, Feb ascent)
      const winterPeaks = progress?.filter(p => {
        if (!p.first_completed_at) return false;
        const month = new Date(p.first_completed_at).getMonth() + 1;
        return month === 12 || month === 1 || month === 2;
      });
      if (winterPeaks?.length > 0) {
        earnedAchievements.push({
          type: 'winter_warrior',
          name: 'Winter Warrior',
          icon: '‚ùÑÔ∏è',
          desc: 'Winter summit (December-February)',
          date: winterPeaks[0]?.first_completed_at,
          category: 'seasons'
        });
      }
      
      // 16. seasonal_hiker - Seasonal Hiker (ascents in all 4 seasons)
      const seasons = new Set();
      progress?.forEach(p => {
        if (!p.first_completed_at) return;
        const month = new Date(p.first_completed_at).getMonth() + 1;
        if (month === 12 || month === 1 || month === 2) seasons.add('winter');
        else if (month >= 3 && month <= 5) seasons.add('spring');
        else if (month >= 6 && month <= 8) seasons.add('summer');
        else seasons.add('fall');
      });
      if (seasons.size === 4) {
        earnedAchievements.push({
          type: 'seasonal_hiker',
          name: 'Seasonal Hiker',
          icon: 'üçÇ',
          desc: 'Ascents in all 4 seasons',
          date: progress[progress.length - 1]?.first_completed_at,
          category: 'seasons'
        });
      }
      
      // 17. week_streak - Week-long Streak (7 consecutive days)
      const dates = progress?.map(p => p.first_completed_at).filter(Boolean).sort();
      let maxStreak = 1, currentStreak = 1;
      let streakDate = dates?.[0];
      for (let i = 1; i < (dates?.length || 0); i++) {
        const prev = new Date(dates[i-1]);
        const curr = new Date(dates[i]);
        const diffDays = Math.round((curr - prev) / (1000 * 60 * 60 * 24));
        if (diffDays === 1) {
          currentStreak++;
          if (currentStreak > maxStreak) {
            maxStreak = currentStreak;
            streakDate = dates[i];
          }
        } else if (diffDays > 1) {
          currentStreak = 1;
        }
      }
      if (maxStreak >= 7) {
        earnedAchievements.push({
          type: 'week_streak',
          name: 'Week-long Streak',
          icon: 'üî•',
          desc: 'Ascents on 7 consecutive days',
          date: streakDate,
          category: 'streaks'
        });
      }
      
      // 20. year_marathon - Yearly Marathon (50 ascents in one year)
      const yearCounts = {};
      progress?.forEach(p => {
        if (!p.first_completed_at) return;
        const year = new Date(p.first_completed_at).getFullYear();
        yearCounts[year] = (yearCounts[year] || 0) + 1;
      });
      const marathonYear = Object.entries(yearCounts).find(([y, c]) => c >= 50);
      if (marathonYear) {
        earnedAchievements.push({
          type: 'year_marathon',
          name: 'Yearly Marathon',
          icon: 'üóìÔ∏è',
          desc: '50 ascents in one year',
          date: `${marathonYear[0]}-12-31`,
          category: 'streaks'
        });
      }
      
      // 24. repeat_offender - Repeat Offender (same peak 10 times)
      const peakCounts = {};
      progress?.forEach(p => {
        peakCounts[p.peak_id] = (peakCounts[p.peak_id] || 0) + 1;
      });
      const repeatPeak = Object.entries(peakCounts).find(([id, c]) => c >= 10);
      if (repeatPeak) {
        earnedAchievements.push({
          type: 'repeat_offender',
          name: 'Repeat Offender',
          icon: 'üîÑ',
          desc: 'Same summit on 10 occasions',
          date: progress[progress.length - 1]?.first_completed_at,
          category: 'special'
        });
      }
      
      const earnedTypes = new Set(earnedAchievements.map(a => a.type));
      
      let html = '';
      
      // Show earned achievements first
      earnedAchievements.forEach(ach => {
        const dateStr = ach.date ? new Date(ach.date).toLocaleDateString('en-US', {
          month: 'short', day: 'numeric', year: 'numeric'
        }) : 'Earned';
        
        html += `
          <div class="achievement-card" title="${ach.desc}" data-category="${ach.category}">
            <div class="achievement-icon">
              <img src="/ico/${ach.type}.png" alt="${ach.name}" class="achievement-icon-img" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'">
              <span class="achievement-icon-emoji" style="display:none">${ach.icon}</span>
            </div>
            <div class="achievement-name">${ach.name}</div>
            <div class="achievement-desc">${ach.desc}</div>
            <span class="achievement-date">${dateStr}</span>
          </div>
        `;
      });
      
      // Show locked achievements
      ALL_ACHIEVEMENTS.filter(a => !earnedTypes.has(a.type)).forEach(ach => {
        html += `
          <div class="achievement-card locked" title="${ach.desc}" data-category="${ach.category}">
            <div class="achievement-icon">
              <img src="/ico/${ach.type}.png" alt="${ach.name}" class="achievement-icon-img" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'">
              <span class="achievement-icon-emoji" style="display:none">${ach.icon}</span>
            </div>
            <div class="achievement-name">${ach.name}</div>
            <div class="achievement-desc">${ach.desc}</div>
            <span class="achievement-date">Not earned</span>
          </div>
        `;
      });
      
      container.innerHTML = html || '<div class="empty-state">Start hiking to earn achievements!</div>';
      
    } catch (e) {
      console.error('Error calculating achievements:', e);
      container.innerHTML = '<div class="empty-state">Could not load achievements</div>';
    }
  }
  
  // =====================================================
  // Load dashboard stats
  // DB Load: list_peaks, user_peak_progress, user_favorite_peaks
  // =====================================================
  async function loadDashboardStats() {
    console.log('loadDashboardStats: Starting, user:', !!currentUser, 'listId:', currentListId);
    
    // Error handling: Check user authentication
    if (!currentUser) {
      console.log('loadDashboardStats: No user, skipping');
      document.getElementById('dashboardStats').style.display = 'none';
      return;
    }
    
    try {
      let completed = 0;
      let totalPeaks = 0;
      
      // If we have a specific list, get stats for that list
      if (currentListId) {
        // DB Load: Get all peaks in the current list from list_peaks
        const { data: listPeaks, error: listError } = await supabase
          .from('list_peaks')
          .select('peak_id')
          .eq('list_id', currentListId);
        
        if (listError) {
          console.warn('loadDashboardStats: DB Load list_peaks Error:', listError);
        }
        
        totalPeaks = listPeaks?.length || 0;
        
        // DB Load: Get completed peaks for this list from user_peak_progress
        const { data: completedPeaks, error: completedError } = await supabase
          .from('user_peak_progress')
          .select('peak_id')
          .eq('user_id', currentUser.id)
          .eq('list_id', currentListId)
          .eq('completed', true);
        
        if (completedError) {
          console.warn('loadDashboardStats: DB Load user_peak_progress Error:', completedError);
        }
        
        completed = completedPeaks?.length || 0;
      } else {
        // No list - get all completed peaks across all lists
        console.log('loadDashboardStats: No list ID, getting all completed peaks');
        
        // DB Load: Get all completed peaks from user_peak_progress
        const { data: allCompleted, error: allError } = await supabase
          .from('user_peak_progress')
          .select('peak_id')
          .eq('user_id', currentUser.id)
          .eq('completed', true);
        
        if (allError) {
          console.warn('loadDashboardStats: DB Load all completed Error:', allError);
        }
        
        completed = allCompleted?.length || 0;
        totalPeaks = 48; // Default to NH48
      }
      
      // DB Load: Get favorites from user_favorite_peaks (not list-specific)
      const { data: favoritePeaks, error: favError } = await supabase
        .from('user_favorite_peaks')
        .select('peak_id')
        .eq('user_id', currentUser.id)
        .eq('favorite_type', 'favorite');
      
      if (favError) {
        console.warn('loadDashboardStats: DB Load favorites Error:', favError);
      }
      
      const favoritesCount = favoritePeaks?.length || 0;
      
      // DB Load: Get wishlist from user_favorite_peaks
      const { data: wishlistPeaks, error: wishError } = await supabase
        .from('user_favorite_peaks')
        .select('peak_id')
        .eq('user_id', currentUser.id)
        .eq('favorite_type', 'wishlist');
      
      if (wishError) {
        console.warn('loadDashboardStats: DB Load wishlist Error:', wishError);
      }
      
      const wishlistCount = wishlistPeaks?.length || 0;
      
      // Calculate percentage
      const percentage = totalPeaks > 0 ? Math.round((completed / totalPeaks) * 100) : 0;
      
      console.log('loadDashboardStats: Stats -', { completed, totalPeaks, favoritesCount, wishlistCount, percentage });
      
      // Get the current list name for the label
      const currentList = allLists.find(l => l.id === currentListId);
      const listName = currentList ? currentList.name : 'All Lists';
      
      // Update UI
      document.getElementById('statTotalCompleted').textContent = `${completed}/${totalPeaks}`;
      document.getElementById('statFavorites').textContent = favoritesCount;
      document.getElementById('statWishlist').textContent = wishlistCount;
      document.getElementById('statPercentComplete').textContent = percentage + '%';
      document.getElementById('statListName').textContent = listName;
      document.getElementById('dashboardStats').style.display = 'block';
      
      // Load activity graph
      await loadActivityGraph();
    } catch (e) {
      console.error('Error loading dashboard stats:', e);
      // Still show the dashboard with zeros if there's an error
      document.getElementById('dashboardStats').style.display = 'block';
    }
  }
  
  // =====================================================
  // Load GitHub-style pulse graph (208 dots / 2 years)
  // DB Load: user_peak_progress
  // =====================================================
  async function loadActivityGraph() {
    // Error handling: Check user authentication
    if (!currentUser) {
      console.log('loadActivityGraph: No user, skipping');
      return;
    }
    
    const pulseGraph = document.getElementById('pulseGraph');
    const pulseHikeCount = document.getElementById('pulseHikeCount');
    if (!pulseGraph) {
      console.log('loadActivityGraph: No pulseGraph element found');
      return;
    }
    
    try {
      // Get all completed peaks with dates from past 2 years
      const twoYearsAgo = new Date();
      twoYearsAgo.setFullYear(twoYearsAgo.getFullYear() - 2);
      
      console.log('loadActivityGraph: DB Load - Fetching completions since', twoYearsAgo.toISOString());
      
      // DB Load: Get completion dates from user_peak_progress
      let { data: completions, error } = await supabase
        .from('user_peak_progress')
        .select('first_completed_at, last_completed_at')
        .eq('user_id', currentUser.id)
        .eq('completed', true);
      
      if (error) {
        console.error('loadActivityGraph: DB Load Error:', error);
        throw error;
      }
      
      // Filter by date in JS (more flexible than SQL date comparison)
      const twoYearsAgoTime = twoYearsAgo.getTime();
      completions = (completions || []).filter(c => {
        const dateStr = c.first_completed_at || c.last_completed_at;
        if (!dateStr) return false;
        return new Date(dateStr).getTime() >= twoYearsAgoTime;
      });
      
      console.log('loadActivityGraph: Found', completions?.length || 0, 'completions in date range');
      
      // Build period-by-period activity map (208 periods over 2 years = ~3.5 days each)
      const periodMap = {}; // key: period index -> count
      let totalHikes = 0;
      const today = new Date();
      const msPerPeriod = (2 * 365.25 * 24 * 60 * 60 * 1000) / 208; // ~3.5 days per period
      
      if (completions) {
        completions.forEach(c => {
          const dateStr = c.first_completed_at || c.last_completed_at;
          if (!dateStr) return;
          
          const date = new Date(dateStr);
          const daysAgo = (today.getTime() - date.getTime()) / (24 * 60 * 60 * 1000);
          const periodIndex = Math.floor(207 - (daysAgo / 3.5)); // 0-207, 207 = most recent
          
          if (periodIndex >= 0 && periodIndex < 208) {
            periodMap[periodIndex] = (periodMap[periodIndex] || 0) + 1;
            totalHikes++;
          }
        });
      }
      
      // Update total count
      pulseHikeCount.textContent = `${totalHikes} peaks in this period`;
      
      // Generate 208 dots (2 years)
      const periods = [];
      for (let i = 0; i < 208; i++) {
        const daysAgo = (207 - i) * 3.5;
        const periodDate = new Date(today.getTime() - (daysAgo * 24 * 60 * 60 * 1000));
        periods.push({
          index: i,
          count: periodMap[i] || 0,
          date: periodDate
        });
      }
      
      // Find max for intensity scaling
      const maxCount = Math.max(...periods.map(p => p.count), 1);
      
      // Build the pulse graph HTML (208 dots in a flowing grid)
      let html = '<div style="display:flex;flex-wrap:wrap;gap:2px">';
      
      periods.forEach(period => {
        const intensity = period.count === 0 ? 0 : Math.min(Math.ceil((period.count / maxCount) * 4), 4);
        const colors = [
          'rgba(34,197,94,0.1)',  // 0: empty
          'rgba(34,197,94,0.3)',  // 1: light
          'rgba(34,197,94,0.5)',  // 2: medium
          'rgba(34,197,94,0.75)', // 3: high
          '#22c55e'               // 4: max
        ];
        const color = colors[intensity];
        const monthName = period.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        const tooltip = period.count > 0 
          ? `${period.count} peak${period.count > 1 ? 's' : ''} - ${monthName}`
          : `No activity - ${monthName}`;
        
        html += `<div style="width:8px;height:8px;border-radius:2px;background:${color};cursor:pointer" title="${tooltip}"></div>`;
      });
      
      html += '</div>';
      
      // Add month labels below
      html += '<div style="display:flex;justify-content:space-between;margin-top:8px;font-size:10px;color:var(--ink-weak)">';
      const months = ['Jan', 'Apr', 'Jul', 'Oct', 'Jan', 'Apr', 'Jul', 'Oct'];
      const currentMonth = today.getMonth();
      // Show month markers across 2 years
      for (let i = 0; i < 8; i++) {
        const monthsBack = 24 - (i * 3);
        const markerDate = new Date(today);
        markerDate.setMonth(markerDate.getMonth() - monthsBack);
        const monthName = markerDate.toLocaleDateString('en-US', { month: 'short' });
        html += `<span>${monthName}</span>`;
      }
      html += '</div>';
      
      pulseGraph.innerHTML = html;
    } catch (e) {
      console.error('Error loading pulse graph:', e);
      pulseGraph.innerHTML = '<div style="text-align:center;color:var(--ink-weak);padding:20px">Could not load activity data</div>';
    }
  }
  
  // Get ISO week key for a date (kept for backwards compatibility)
  function getWeekKey(date) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    return `${d.getUTCFullYear()}-${String(weekNo).padStart(2, '0')}`;
  }
  
  // =====================================================
  // Data Export Functions
  // =====================================================
  async function exportData(format) {
    if (!currentUser) return;
    
    try {
      // Fetch all user data
      const { data: progress } = await supabase
        .from('user_peak_progress')
        .select('*, peaks(name, slug, elevation), lists(name)')
        .eq('user_id', currentUser.id)
        .eq('completed', true);
      
      const { data: favorites } = await supabase
        .from('user_favorite_peaks')
        .select('*, peaks(name, slug)')
        .eq('user_id', currentUser.id);
      
      const exportData = {
        exportDate: new Date().toISOString(),
        user: {
          email: currentUser.email,
          name: profileName.textContent
        },
        completedPeaks: progress?.map(p => ({
          peak: p.peaks?.name,
          slug: p.peaks?.slug,
          elevation: p.peaks?.elevation,
          list: p.lists?.name,
          completedAt: p.first_completed_at
        })) || [],
        favorites: favorites?.filter(f => f.favorite_type === 'favorite').map(f => ({
          peak: f.peaks?.name,
          slug: f.peaks?.slug
        })) || [],
        wishlist: favorites?.filter(f => f.favorite_type === 'wishlist').map(f => ({
          peak: f.peaks?.name,
          slug: f.peaks?.slug
        })) || []
      };
      
      let content, filename, mimeType;
      
      if (format === 'json') {
        content = JSON.stringify(exportData, null, 2);
        filename = `peakbagger-export-${new Date().toISOString().split('T')[0]}.json`;
        mimeType = 'application/json';
      } else {
        // CSV format
        let csv = 'Peak Name,Slug,Elevation,List,Completed Date,Type\n';
        exportData.completedPeaks.forEach(p => {
          csv += `"${p.peak}","${p.slug}",${p.elevation || ''},"${p.list}","${p.completedAt || ''}","completed"\n`;
        });
        exportData.favorites.forEach(p => {
          csv += `"${p.peak}","${p.slug}","","","","favorite"\n`;
        });
        exportData.wishlist.forEach(p => {
          csv += `"${p.peak}","${p.slug}","","","","wishlist"\n`;
        });
        content = csv;
        filename = `peakbagger-export-${new Date().toISOString().split('T')[0]}.csv`;
        mimeType = 'text/csv';
      }
      
      // Download file
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showMessage(`Data exported as ${format.toUpperCase()}!`);
    } catch (e) {
      console.error('Export error:', e);
      showMessage('Error exporting data', true);
    }
  }
  
  document.getElementById('exportJsonBtn')?.addEventListener('click', () => exportData('json'));
  document.getElementById('exportCsvBtn')?.addEventListener('click', () => exportData('csv'));
  
  // =====================================================
  // Preferences
  // =====================================================
  function loadPreferences() {
    const prefs = JSON.parse(localStorage.getItem('peakbagger_prefs') || '{}');
    document.getElementById('emailNotifications').checked = prefs.emailNotifications !== false;
    document.getElementById('publicProfile').checked = prefs.publicProfile !== false;
    document.getElementById('soundEffects').checked = prefs.soundEffects !== false;
  }
  
  function savePreferences() {
    const prefs = {
      emailNotifications: document.getElementById('emailNotifications').checked,
      publicProfile: document.getElementById('publicProfile').checked,
      soundEffects: document.getElementById('soundEffects').checked
    };
    localStorage.setItem('peakbagger_prefs', JSON.stringify(prefs));
  }
  
  document.getElementById('emailNotifications')?.addEventListener('change', savePreferences);
  document.getElementById('publicProfile')?.addEventListener('change', savePreferences);
  document.getElementById('soundEffects')?.addEventListener('change', savePreferences);
  
  // Load preferences on page load
  loadPreferences();
  
  // =====================================================
  // Modal Functions
  // =====================================================
  const modal = document.getElementById('confirmModal');
  const modalTitle = document.getElementById('modalTitle');
  const modalMessage = document.getElementById('modalMessage');
  const modalCancel = document.getElementById('modalCancel');
  const modalConfirm = document.getElementById('modalConfirm');
  let modalCallback = null;
  
  function showModal(title, message, callback, confirmText = 'Confirm') {
    modalTitle.textContent = title;
    modalMessage.textContent = message;
    modalConfirm.textContent = confirmText;
    modalCallback = callback;
    modal.classList.add('active');
  }
  
  function hideModal() {
    modal.classList.remove('active');
    modalCallback = null;
  }
  
  modalCancel?.addEventListener('click', hideModal);
  modalConfirm?.addEventListener('click', () => {
    if (modalCallback) modalCallback();
    hideModal();
  });
  modal?.addEventListener('click', (e) => {
    if (e.target === modal) hideModal();
  });
  
  // Update sign out to use modal
  signOutBtn.addEventListener('click', () => {
    showModal(
      'Sign Out',
      'Are you sure you want to sign out of your account?',
      async () => {
        await supabase.auth.signOut();
        window.location.href = 'peakbagger-clean.html';
      },
      'Sign Out'
    );
  });
  
  // Main initialization function - called on page load
  async function initializeProfile() {
    try {
      // First load user profile
      await loadUserProfile();
      
      // If user is logged in, load all social features
      if (currentUser) {
        await initializeSocialFeatures();
        
        // Update member badge based on completed peaks (after stats load)
        setTimeout(() => {
          const completed = parseInt(document.getElementById('statTotalCompleted')?.textContent || '0');
          const badge = document.getElementById('memberBadge');
          if (badge) {
            if (completed >= 48) {
              badge.textContent = 'üèÜ NH48 Finisher';
              badge.classList.add('badge-accepted');
            } else if (completed >= 24) {
              badge.textContent = '‚≠ê Experienced Hiker';
            } else if (completed >= 10) {
              badge.textContent = 'ü•æ Active Hiker';
            } else {
              badge.textContent = 'üèîÔ∏è Member';
            }
          }
        }, 500);
      }
    } catch (e) {
      console.error('Error initializing profile:', e);
    }
  }
</script>

</body>
</html>